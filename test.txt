package main

import (
	"fmt"
)

func main() {
	e1 := fmt.Errorf("%s %d %s", "2", 1, "1")
	fmt.Println(e1.Error())
}

type TreeMap struct {
	// 根据key值存储对应的树
	child  map[int]*Tree

	// 存储某个key值的节点当前被挂在的对应子树
	parent map[int]*Tree

	//
	minAlign int

	//
	maxAlign int

	aligns int
}

type Tree struct {
	// 父亲节点
	root int

	// 子节点
	childMap map[int]int

	// 子节点数据
	childData []int

	// 当前竖行 以0行为起始，不断减值
	alignLine int
}

func test(key int, path [][]int) {
	treeMap := TreeMap{
		child:    make(map[int]*Tree, len(path)),
		parent:   make(map[int]*Tree, len(path)),
		minAlign: 0,
		maxAlign: 0,
	}
	root := NewTree(len(path[0]) - 2)
	root.root = key
	rootChild := make([]int, 0, len(path[0])-2)
	for _, c := range path[1] {
		if c == 1 {
			rootChild = append(rootChild, c)
			// TreeMap.paren[c] = root
			treeMap.parent[c] = root
		}
	}
	// 当前分裂成了N行
	treeMap.aligns += len(rootChild)
	root.childData = rootChild
	//
	curAtom := NewTree(len(path[2])-2)
	curAtom.root = 2
	child := path[2]
	for _, v := range child {
		if curParent, ok := treeMap.parent[v]; ok {
			if v - curParent.root > v - curAtom.root {
				treeMap.parent[v] = curAtom
				treeMap.aligns--
			}
		}
	}
}

func NewTree(n int) *Tree {
	return &Tree{
		childMap:  make(map[int]int, n),
		childData: make([]int, 0, n),
		alignLine: 0,
	}
}
